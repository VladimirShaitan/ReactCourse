# Автоматне програмування

Тема кінцевих автоматів займає центральне місце у фронтенд-розробці. Інтерактивні елементи завжди залучені до процесів, пов’язаних зі зміною станів. 
Модальні вікна можуть бути відкритими або прихованими, кнопка натиснута, віджата або заблокована (наприклад, під час AJAX-запиту). Прикладів безліч. 
Часто ці автомати залежать один від одного, що породжує ієрархію автоматів. 
Наприклад, можливість взаємодії з елементом на екрані може з’явитися тільки після натискання кнопки “редагувати”.

У React робота з автоматами проста до неподобства і в більшості випадків не потребує використання спеціальних бібліотек. 
Візьмемо, наприклад, кнопку, яка відповідає за показ шматка тексту. Її стани можна описати так:

1.	За замовчуванням текст прихований (стан hidden).
2.	Клік по кнопці відображає текст (стан shown).
3.	Повторний клік ховає текст (hidden).

У цьому випадку у кнопки два стани, тому можна спростити задачу і використовувати прапорець як індикатор стану. Назвемо його isShown.

Використовувати прапорці з булевими значеннями дуже не рекомендується на бекенді, коли стан зберігається у базі даних. 
Ціна зміни автомата занадто висока (зміна типу колонки з boolean на string), тому навіть у випадку бінарної логіки краще робити повноцінний автомат із названими станами. 
Іншими словами, для зберігання стану використовуйте не булеве поле (з true/false), а текстове поле, у якому буде міститися повна назва стану. 
Наприклад, якщо стаття може перебувати у двох станах (“опублікована” або “не опублікована”), то потрібно створювати не поле published: bool зі значеннями true і false, а поле publishing_state зі значеннями published і unpublished.

Приклад — lesson-files/automate/src/components/Component.jsx

Більша частина коду в React (як і у всьому фронтенді) виглядає саме так, як у прикладі вище. Події породжують зміни стану у даних, на основі яких, у свою чергу, змінюється уявлення. 
Кількість кінцевих автоматів у фронтенд-додатках зростає з астрономічною швидкістю, головне їх бачити і виділяти явно.

# Структура стану

Дані, з якими працює React, зазвичай надходять із бекенду. І ці дані теж беруть участь у різних процесах і перебувають у різних станах. 
Наприклад, стаття може бути опублікована або не опублікована. І залежно від того, у якому вона стані, формується UI. І тут починається найцікавіше. 

Конкретно стан опублікованості статті не є частиною UI, але UI використовує цей стан, а під час змін він синхронізується на фронтенді та бекенді. Але в UI часто з’являються стани, які відповідають виключно за зовнішній вигляд, 
але не є частиною даних.

Якщо припустити, що дані, отримані з бекенду, всередині нашого об’єкта-стану зберігаються як список під ключем items, то виникає питання: 
куди записувати дані, що відповідають за стан UI? 
Тобто ті самі стани, які з’являються лише під час взаємодії з користувачем і не використовуються на серверній стороні?

Приклад: з бекенду надходить стаття такої структури: 
```js
{ id: 3, name: 'How to program', state: 'published' }
```
Вона відправляється у items. А в UI є можливість увійти в її редагування, і для цього використовується прапорець (стан) isEditing, який існує тільки на екрані. 
Питання: де зберігати цю змінну?

Найпростіший варіант: змінити саму статтю всередині items так, щоб вона мала такий вигляд: 
```js
{ id: 3, name: 'How to program', state: 'published', isEditing: true }
``` 
Хоча на перший погляд це здається розумним, проблем він приносить більше, ніж користі. 
Основні проблеми пов’язані із завданнями синхронізації. Іноді потрібно надіслати всю статтю на сервер (після змін), а іноді перечитати її заново з бекенду. 
У такій ситуації потрібно буде або вилучати тільки потрібні дані, або постійно робити “мердж” (злиття), щоб не втратити стан UI. 
Практика показала, що набагато простіше додавати окремий список виключно для завдань збереження стану UI. 
Тобто в state з’явиться список під назвою itemUIStates, і для статті в нього додасться елемент 
```js
{ articleId: 3, isEditing: true }
```