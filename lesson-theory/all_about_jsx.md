# _Що таке JSX?_

**JSX (JavaScript XML)** — це синтаксичне розширення JavaScript, яке використовується в React для опису
користувацького інтерфейсу (UI). 
JSX дозволяє розробникам писати HTML-подібний код безпосередньо в JavaScript. 

Це не є стандартною частиною JavaScript, але його можна використовувати завдяки транспіляторам, 
таким як Babel, які перетворюють JSX у звичайний JavaScript-код.


### _Синтаксис JSX:_

```jsx
const element = <h1>Hello, World!</h1>;
```
Код вище компілюється в:
```jsx
const element = React.createElement('h1', null, 'Hello, World!');
```
У цьому прикладі null у функції React.createElement означає, 
що у створюваного елемента немає властивостей (або атрибутів).
React.createElement створює об’єкт, який React використовує для побудови та оновлення DOM.


### _Де використовується JSX?_

JSX є основою роботи з React і застосовується в таких випадках:

1.	Створення компонентів UI:
JSX дозволяє описувати інтерфейс як набір компонентів, кожен з яких може містити HTML-подібний код 
і JavaScript-логіку.

2.	Відображення динамічного контенту:
У JSX можна використовувати вирази JavaScript всередині фігурних дужок {} для створення 
інтерактивного контенту.

```jsx
const user = 'John';
const element = <h1>Hello, {user}!</h1>;
```

3.	Управління станом і подіями:
JSX дозволяє створювати динамічні інтерфейси, які реагують на зміни стану компонентів 
або взаємодію з користувачем. Про це ми поговоримо пізніше.


## **Відмінності між JSX та HTML**

Хоча JSX і намагається бути схожим на HTML, між ними все ж є деякі відмінності.

**Закриття тегів:**
У JSX потрібно закривати всі теги, навіть ті, які зазвичай не закриваються в HTML:
```jsx
<img src="image.png" />
```

**Відсутність двійкових атрибутів:**
Якщо атрибуту не задається значення, він автоматично стає рівним true:
```jsx
<input disabled />
```

В JSX усі властивості DOM і атрибути (включаючи обробники подій) повинні записуватися у форматі camelCase. 
Наприклад, атрибут tabindex перетворюється на tabIndex. 
```jsx
<div tabIndex="0"></div>  // camelCase
```

Винятком є атрибути aria- та data-, які записуються так само, як і в звичайному HTML.

**Ключове слово class:**
У JSX для позначення класів стилів використовується className замість class:
```jsx
<div className="container"></div>
```


### _htmlFor_

Оскільки for — це зарезервоване слово в JavaScript, у React-компонентах використовується властивість htmlFor.


### _Екранування_

Звичайний HTML не дуже безпечний. 
Будь-який текст, який має залишатися текстом, необхідно екранувати перед виведенням. 
В іншому випадку, якщо всередині буде HTML, він буде інтерпретований. Це може бути небезпечно, 
якщо цей текст на сайт додають самі користувачі.

JSX працює інакше. Усе, що виводиться звичайним способом, за замовчуванням є безпечним і 
автоматично екранується. У тих місцях, де екранування не потрібне, воно відключається таким чином:

lesson-files/examples/src/components/HtmlRender.jsx

```jsx
HtmlRender.jsx

import React from "react";

class HtmlRender extends React.Component {
    render() {
        const htmlString = 'This <i>text</i> should be rendered <b>"as is"</b>';
        return (
            <ul>
                <li dangerouslySetInnerHTML={{ __html: htmlString }} />
                <li>{htmlString}</li>
            </ul>
        );
    }
}

export default HtmlRender;
```

Для виведення без екранування потрібно використовувати властивість dangerouslySetInnerHTML. 
У цю властивість передається об’єкт із властивістю __html, значенням якого є рядок із HTML. 

#### Зверніть увагу: якщо у компонента визначений атрибут dangerouslySetInnerHTML, 
### то вміст у такого компонента бути не може. Наступний приклад призведе до помилки:

```jsx
<div dangerouslySetInnerHTML={{ __html: '<p>content<p>' }}>more content</div>;
```

### _Стилі_

Атрибут style працює зовсім інакше. Якщо в HTML це звичайний рядок, то в JSX це об’єкт.

lesson-files/examples/src/components/CssRender.jsx

```jsx
CssRender.jsx

import React from "react";

class CssRender extends React.Component {
    render() {
        const divStyle = {
            color: 'blue',
            fontSize: '50px',
        };

        return <div style={divStyle}>Hello World!</div>;
    }
}

export default CssRender;
```
Для узгодженості з іменами атрибутів, імена CSS-властивостей також повинні записуватися у стилі camelCase.

### _Динамічний контент:_

У JSX можна використовувати JavaScript-вирази всередині фігурних дужок {}:
```jsx
const isLoggedIn = true;
<div>{isLoggedIn ? 'Welcome back!' : 'Please log in.'}</div>
```

### _Значення властивостей за замовчуванням_

Якщо властивість передається в компонент без значення, то вона автоматично стає рівною true.

Нижченаведені приклади еквівалентні:

```jsx
<MyTextBox autocomplete />

<MyTextBox autocomplete={true} />
```
При цьому перший варіант є рекомендованим.

## Переваги JSX

1.	Зрозумілість коду:
JSX дозволяє писати UI-компоненти у зручному форматі, що спрощує їх читання та підтримку.

2.	Інтеграція з JavaScript:
Використання JavaScript виразів дозволяє створювати динамічні та інтерактивні компоненти.

3.	Узгодженість:
JSX має строгі правила синтаксису, що сприяє єдності стилю коду в команді.

## Недоліки JSX

1.	Додаткова транспіляція:
JSX не є стандартною частиною JavaScript, тому вимагає компіляції перед виконанням.

2.	Крива навчання:
Розробникам, які звикли до HTML, може знадобитися час для адаптації до нового синтаксису.

3.	Залежність від інструментів:
Для роботи з JSX потрібні спеціальні інструменти, такі як Babel.